#include "defines.h"
#include "Memory.h"
#include "Hardware/Beeper.h"
#include <cstring>

#include "Hardware/HAL/HAL.h"


using HAL::EEPROM_;
using HAL::OTP_;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ¬озвращает адрес первого свободного байта в секторе настроек
static uint FirstFreeAddressForSettings();
/// \brief ¬озвращает адрес сохранЄнных настроек или 0, если настройки не сохран€лись. fromEnd указывает, какие настройки от конца
/// нужно загружать - 0 - последние, 1 - предпоследние и так далее
static uint AddressSavedSettings(int fromEnd);

static void ReadBytes(uint address, void *data, uint size);

static uint ReadDoubleWord(uint address);


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// ѕервый сектор дл€ сохранени€ настроек. ѕри его заполнении начинает использоватьс€ сектор 2.
#define ADDR_SECTOR_SETTINGS_1  ((uint)0x080C0000)
/// ¬торой сектор дл€ сохранени€ настроек. ѕри его заполнении начинает использоватьс€ сектор 1.
#define ADDR_SECTOR_SETTINGS_2  ((uint)0x080E0000)

#define SIZE_SECTOR_128         (128 * 1024)

#define READ_BYTE(address)      (*((uint8 *)address))


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Memory::SaveSettings()
{
    /*
        јлгоритм нахождени€ первого свободного слова
        1. текущий адрес = (uint*)ADDR_SECTOR_SETTINGS_1.
        2. —мотрим, что записано по текущему адресу
        2. ≈сли там 0xffffffff, то это первое свободное слово - выходим.
        3. ѕрибавл€ем к текущему адресу значение *((uint*)ADDR_SECTOR_SETTINGS_1).
        4. ѕереходим к 2
    */
    /*
        1. «аписываем в Settings.size значение sizeof(Settings)
        2. Ќаходим адрес первого свободного байта (алгоритм выше)
        3. Ќаходим размер_свободной_пам€ти = ADDR_SECTOR_SETTINGS_1 + (128 * 1024) - адрес_первого_свободного_слова
        4. ≈сли размер_свободной_пам€ти > размер_структуры_настроек, то сохран€ем по найденному адресу структуру Settings и выходим.
        5. »наче стираем сектор настроек и записываем в его начало структуру Settings
    */

    /// \todo ќдного сектора дл€ хранени€ настроек недостаточно, потому что после стирани€ может отключитьс€ питание и тогда сотрутс€ все настройки

    set.size = sizeof(set);

    uint address = FirstFreeAddressForSettings();

    uint freeMemory = ADDR_SECTOR_SETTINGS_1 + SIZE_SECTOR_128 - address;

    if(address == MAX_UINT || freeMemory <= sizeof(Settings))
    {
        EEPROM_::EraseSector(ADDR_SECTOR_SETTINGS_1);
        address = ADDR_SECTOR_SETTINGS_1;
    }

    set.size = sizeof(set);
    EEPROM_::WriteBytes(address, (uint8 *)&set, sizeof(set));
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
static uint FirstFreeAddressForSettings() //-V2506
{
    uint address = ADDR_SECTOR_SETTINGS_1;

    do
    {
        uint value = ReadDoubleWord(address);

        if (value == MAX_UINT)              // Ёто условие означает, что по этому адресу ещЄ ничего не записывалось, иначе здесь был бы записан
        {                                   // размер структуры (Settings), чьим первым байтом €вл€лось бы это слово
            return address;
        }

        address += value;                   // ѕереходим на первый свободный байт за структурой

    } while(address < (ADDR_SECTOR_SETTINGS_1 + SIZE_SECTOR_128));
    
    
    return MAX_UINT;        // ¬ообще-то до этой точки дойти никак не может. ≈сли мы оказались здесь, произошла ошибка
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
static uint AddressSavedSettings(int)
{
    uint addrPrev = 0;

    uint address = ADDR_SECTOR_SETTINGS_1;

    while (ReadDoubleWord(address) != MAX_UINT)
    {
        addrPrev = address;
        address += ReadDoubleWord(address);
    }

    return addrPrev;
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
static void ReadBytes(uint address, void *data, uint size)
{
    uint8 *buffer = (uint8 *)data;

    for (uint i = 0; i < size; i++)
    {
        buffer[i] = READ_BYTE(address++);
    }
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
bool Memory::GetData(int /*num*/, DataSettings * /*ds*/, uint8 * /*dataA*/, uint8 * /*dataB*/)
{
    return false;
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void Memory::DeleteData(int /*num*/)
{
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void Memory::GetDataInfo(bool /*existData*/[MAX_NUM_SAVED_WAVES])
{
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void Memory::SaveData(int /*num*/, const DataSettings * /*ds*/, uint8 * /*dataA*/, uint8 * /*dataB*/)
{
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
void Memory::DeleteAllData()
{
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
String OTPmem::GetSerialNumber(int *freeForWrite)
{
    char buffer[20];
    *freeForWrite = OTP_::GetSerialNumber(buffer);
    return String(buffer);
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
bool OTPmem::SaveSerialNumber(char *servialNumber) //-V2506
{
    return OTP_::SaveSerialNumber(servialNumber);
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
static uint ReadDoubleWord(uint address)
{
    return (*((uint *)address));
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
bool Memory::LoadSettings()
{
    uint address = AddressSavedSettings(0);

    if (address && ReadDoubleWord(address) == sizeof(set))
    {
        ReadBytes(address, &set, ReadDoubleWord(address));
        return true;
    }

    return false;
}
