#include "defines.h"
#include "Hardware/HAL/HAL.h"
#include "Hardware/HAL/HAL_PIO.h"
#include <stm32f4xx_hal.h>


struct OutPin
{
    OutPin(HPort::E _port, uint16 _pin) : port(_port), pin(_pin) {}

    void Init()       { HAL_PIO::Init(port, pin, HMode::Output_PP, HPull::Up); SetPassive(); }
    void SetActive()  { HAL_PIO::Reset(port, pin); }
    void SetPassive() { HAL_PIO::Set(port, pin); }

    HPort::E port;
    uint16 pin;
};


struct InPin
{
    InPin(HPort::E _port, uint16 _pin) : port(_port), pin(_pin) {}

    void Init()      { HAL_PIO::Init(port, pin, HMode::Input, HPull::Up); }
    bool IsActive()  { return HAL_PIO::Read(port, pin) == 0; };
    bool IsPassive() { return HAL_PIO::Read(port, pin) == 1; };

    HPort::E port;
    uint16 pin;
};


struct DataBus
{
    /// Первоначальная инициализация
    static void Init();
    /// Сконфигурировать для чтения
    static void ConfigureToRead();
    /// Прочитать байт с шины данных
    static uint8 Read();
    /// Сконфигурировать для записи
    static void ConfigureToWrite();
    /// Записать байт в шину данных
    static void Write(uint8 byte);
};


/// По активному состоянию этого пина панель определяет, что главный МК готов к взаимодействию
static OutPin pinCS(PIN_CS);
/// По активновному состоянию этого пина панель определяте, что главный МК хочет делать передачу
static OutPin pinWR(PIN_WR);
/// По активному состоянию этого пина панель определяте, что главный МК хочет делать чтение
static OutPin pinRD(PIN_RD);

/// Активным состоянием этого пина панель сообщает о готовности к взаимодействию
static InPin pinReadyPAN(PIN_PAN_READY);
/// Активное состояние этого пина сообщает о том, что панель имеет данные для пеередчи
static InPin pinDataPAN(PIN_PAN_DATA);

/// true означает, что шина находится в процессе обмена с панелью и запись по обычной FSMC в альтеру и память запрещена
static bool interactionWithPanel = false;

/// Записать один байт в панель
static void SendByteToPanel(uint8 byte);


void HAL_FSMC::InitPanel()
{
    pinReadyPAN.Init();
    pinDataPAN.Init();
    pinCS.Init();

    DataBus::Init();
}


void HAL_FSMC::ConfigureToPanel(bool forWrite)
{
    mode = Mode::Panel;

    pinWR.Init();
    pinRD.Init();

    if(forWrite)
    {
        DataBus::ConfigureToWrite();
    }
    else
    {
        DataBus::ConfigureToRead();
    }
}


bool HAL_FSMC::Receive()
{
    interactionWithPanel = true;

    if(mode != Mode::Panel)
    {
        ConfigureToPanel(false);
    }


    interactionWithPanel = false;

    return false;
}


void HAL_FSMC::SendToPanel(uint8 byte)
{
    SendToPanel(&byte, 1);
}


void HAL_FSMC::SendToPanel(uint8 byte0, uint8 byte1)
{
    uint8 buffer[2] = { byte0, byte1 };
    
    SendToPanel(buffer, 2);
}


void HAL_FSMC::SendToPanel(uint8 *data, uint size)
{
    interactionWithPanel = true;

    if(mode != Mode::Panel)
    {
        ConfigureToPanel(true);
    }

    for(uint i = 0; i < size; i++)
    {
        SendByteToPanel(*data++);
    }

    interactionWithPanel = false;
}


static void SendByteToPanel(uint8 byte)
{
    DataBus::Write(byte);               // Выставляем данные на шину

    pinWR.SetActive();                  // Даём сигнал записи

    while(pinReadyPAN.IsPassive()) {}   // И ожидаем сигнал панели о том, что она свободна

    pinCS.SetActive();                  // Даём признак того, чта данные выставлены и можно их считывать

    while(pinReadyPAN.IsActive()) {}    // Переключение PIN_PAN_READY в неактивное состояние означает, что панель приняла данные и обрабатывает их

    pinWR.SetPassive();                 // \ Устанавливаем WR и CS в неактивное состояние - элементарный цикл записи окончен
    pinCS.SetPassive();                 // /
}


bool HAL_FSMC::InteractionWithPanel()
{
    return interactionWithPanel;
}


void DataBus::Init()
{
    ConfigureToRead();
}


void DataBus::ConfigureToRead()
{
    GPIO_InitTypeDef gpio;

    gpio.Mode = GPIO_MODE_INPUT;
    gpio.Pull = GPIO_PULLDOWN;

    gpio.Pin = GPIO_PIN_0  |        // D2
               GPIO_PIN_1  |        // D3
               GPIO_PIN_14 |        // D0
               GPIO_PIN_15;         // D1
    HAL_GPIO_Init(GPIOD, &gpio);

    gpio.Pin = GPIO_PIN_7  |        // D4
               GPIO_PIN_8  |        // D5
               GPIO_PIN_9  |        // D6
               GPIO_PIN_10;         // D7
    HAL_GPIO_Init(GPIOE, &gpio);
}


void DataBus::ConfigureToWrite()
{
    GPIOD->MODER &= 0x0ffffff0U;        // Настроим пины 14, 15, 0, 1 на запись D0, D1, D2, D3
    GPIOD->MODER |= 0x50000005U;        // Устанавливаем для этих пинов GPIO_MODE_OUTPUT_PP

    GPIOE->MODER &= 0xffc03fffU;        // Настроим пины 7, 8, 9, 10 на запись D4, D5, D6, D7
    GPIOE->MODER |= 0x00154000U;        // Устанавливаем для этих пинов GPIO_MODE_OUTPUT_PP
}


void DataBus::Write(uint8 d)
{
    //                                                                             биты 0,1                                 биты 2,3
    GPIOD->ODR = (GPIOD->ODR & 0x3ffc) + static_cast<uint16>((static_cast<int16>(d) & 0x03) << 14) + ((static_cast<uint16>(d & 0x0c)) >> 2);  // Записываем данные в выходные пины
    //                                                                          Биты 4,5,6,7
    GPIOE->ODR = (GPIOE->ODR & 0xf87f) + static_cast<uint16>((static_cast<int16>(d) & 0xf0) << 3);
}


uint8 DataBus::Read()
{
    uint8 result = HAL_PIO::Read(PIN_D7);
    result <<= 1;
    result |= HAL_PIO::Read(PIN_D6);
    result <<= 1;
    result |= HAL_PIO::Read(PIN_D5);
    result <<= 1;
    result |= HAL_PIO::Read(PIN_D4);
    result <<= 1;
    result |= HAL_PIO::Read(PIN_D3);
    result <<= 1;
    result |= HAL_PIO::Read(PIN_D2);
    result <<= 1;
    result |= HAL_PIO::Read(PIN_D1);
    result <<= 1;
    result |= HAL_PIO::Read(PIN_D0);

    return result;
}
