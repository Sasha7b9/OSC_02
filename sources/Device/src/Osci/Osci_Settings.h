#pragma once
#include "Settings/SettingsOsci.h"


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define SET_RSHIFT(ch)          (Osci::Settings::RShift::Value(ch))
#define SET_RSHIFT_A            (SET_RSHIFT(Chan::A))
#define SET_RSHIFT_B            (SET_RSHIFT(Chan::B))

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
namespace Osci
{
    namespace Settings
    {
        /// Установить значение удержания синхронизации
        void LoadHoldfOff();

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        struct Range
        {
            static void Change(Chan::E ch, int delta);
            /// Загружаться эта настройка может только для обоих каналов одновременно
            static void LoadBoth();

            enum E
            {
                _2mV,
                _5mV,
                _10mV,
                _20mV,
                _50mV,
                _100mV,
                _200mV,
                _500mV,
                _1V,
                _2V,
                _5V,
                _10V,
                _20V,
                Size
            } value;
            explicit Range(E v) : value(v) {};
            pString Name() const;

            static void Set(Chan::E ch, E range);

            pString ToString(int8 divider);

        };

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        struct RShift
        {
            /// Это значение соответствует минимуму смещения
            static const int MIN = 20;
            /// Это значение соотвествует максимуму смещения
            static const int MAX = 980;
            /// Это значение соответствует середине экрана
            static const int ZERO = 500;
            /// Изменить на delta
            static void Change(Chan::E ch, int delta);
            /// Установить значение
            static void Set(Chan::E ch, uint16 rShift);
            /// Загрузить в аппаратуру
            static void Load(Chan::E ch);
            /// Отрисовать оба на экране
            static void DrawBoth();
            /// Преобразовать в строку
            static String ToString(uint16 rShiftRel, Osci::Settings::Range::E range, int8 divider);
            /// Возвращает ссылку на значение
            static uint16 &Value(Chan::E ch);
        private:
            /// Отрисовать маркер вертикального смещения на сетке
            static void Draw(Chan::E ch);
        };

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        namespace Trig
        {
            /// Возвращает true в случае наличия синхроимпульса
            bool SyncPulse();
            /// Вывести уровень синхронизации поверх сетки
            void DrawOnGrid();
            /// После вызова этой функции уровень синхронизации будет отрисовываться поверх сигнала в течение timMS миллисекунд
            static void NeedForDraw();

            struct Level
            {
                static const int MIN = 20;
                static const int MAX = 980;
                static const int ZERO = 500;
                /// Загрузить уровень синхронизации в аппаратную часть
                static void Load();
                /// Изменить уровень синхронизации на delta единиц
                static void Change(int delta);
                /// Установить заданный уровень синхронизации
                static void Set(int level);
                /// Однократно найти уровень синхронизации
                static void Find();
            };

            extern bool pulse;
        };

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        class TShift
        {
        public:
            static int Min();
            static int Zero();
            static int Max();

            static void Set(int tShift);

            static void Load();

            static void Change(int delta);

            static String ToString(TBase::E tBase);
        };

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        struct PeakDetMode
        {
            enum E
            {
                Disabled,
                Enabled,
                Average
            } value;
            explicit PeakDetMode(E v) : value(v) {};
        };

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        namespace Memory
        {
            /// Число точек сигнала, с которым идёт работа.
            struct ENumPointsFPGA
            {
                enum E
                {
                    _512,
                    _1k,
                    _2k,
                    _4k,
                    _8k,
                    Size
                } value;
                explicit ENumPointsFPGA(E v) : value(v) {};
                uint BytesInChannel(PeakDetMode::E mode) const;
                uint PointsInChannel() const;
            };
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// Положение точки синхронизация на сигнале.
        struct TPos
        {
            enum E
            {
                Left,          ///< Привязка к левому краю.
                Center,        ///< Привязка к центру.
                Right          ///< Привязка к правому краю.
            } value;
            explicit TPos(E v) : value(v) {};
            /// Узнать привязку отсительно уровня синхронизации в байтах
            int InBytes();
        };

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// Тип выборки для режима рандомизатора.
        struct SampleType
        {
            enum E
            {
                Real,    ///< реальное время - в построении участвуют только реально считанные точки, ничего не рассчитывается.
                Equal    ///< эквивалентная - сигнал строится по последним точкам, полученным от рандомизатора.
            } value;
            explicit SampleType(E v) : value(v) {};
        };

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// Функция ВР/ДЕЛ.
        struct FunctionTime
        {
            enum E
            {
                Time,
                ShiftInMemory
            } value;
        };

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// Тип привязки к смещению по горизонтали
        struct LinkingTShift
        {
            enum E
            {
                Time,     ///< Смещение привязано к времени
                Position  ///< Смещение привязано к позиции
            } value;
        };
    }
}
