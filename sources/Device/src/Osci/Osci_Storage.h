#pragma once
#include "Data/DataSettings.h"


namespace FPGA
{
    class DataAccessor;
    class StorageAccessor;
}

class Reader;

class Buffer;

namespace Osci
{
    class DataAccessor;
    class StorageAccess;
    class DataP2P;
    class Storage;

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class Data
    {
    friend class DataAccessor;
    friend class FPGA::DataAccessor;
    friend class DataP2P;
    public:
        void Create();
        const uint8 *DataA();
        const uint8 *DataB();
        const uint8 *GetData(Chan::E ch);
        const DataSettings *Settings();
    protected:
        /// Указатель на данные первого канала
        uint8 *dataA;
        /// Указатель на данные второго канала
        uint8 *dataB;
        /// Порядковый номер данных
        uint num;
        /// Сколько всего данных уже есть
        static uint allDatas;
        /// Настройки сигналов
        DataSettings settings;
    };

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class DataP2P
    {
    friend class DataAccessor;
    friend class Storage;
    public:
        void Logging() const;
        /// time - время, когда были считаны точки
        void AddPoints(uint timeMS, BitSet16 pointA, BitSet16 pointB);
        const uint8 *DataA();
        const uint8 *DataB();
        const DataSettings *Settings();
        /// Заполнить buffer данными для вывода на экран
        void FillBufferForDraw(Chan::E ch, Buffer *buffer);
    private:
        void Create();
        /// Время, в которое должна прийити точка numPoint
        float TimePointMS(uint numPoint) const;
        /// Возвращает true, если считано меньше точек, чем требуется для данного времени
        bool NeedAdditionPoints(uint timeMS) const;
        /// Количество считанных точек
        uint readingPoints;
        /// Указатель на положение точки, которая будет считываться следующей
        uint pointer;
        /// Время начала съёма информации. Первая точка будет поставлена через время, соответствующее TBase
        uint timeStart;

        Data data;
        /// Заполнить буфер для отрисовки при включенном детекторе
        void FillBufferForPeakDetEnabled(Chan::E ch, Buffer *buffer);
        /// Заполнить буфер для отрисовки при выключенном детекторе
        void FillBufferForPeakDetDisabled(Chan::E ch, Buffer *buffer);
        /// Подготовить буфер к заполнению данными
        void PrepareBuffer(Buffer *buffer, uint size);
    };

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class Storage
    {
    friend class FPGA::StorageAccessor;
    friend class ::Reader;
    friend class StorageAccessor;
    private:
        /// Подготавливает место в хранилище для новых данных. Возвращает указатель на структуру, которую можно заполнять данными
        static Data *PrepareForNewData();
        /// Возвращает указатель на данные
        static Data *GetData(int fromEnd = 0);
    public:
        /// Подготавливает новый фрейм для хранения данных поточечного вывода
        static void PrepareNewFrameP2P();
        /// Возвращает фрейм поточечного вывода
        static DataP2P *GetFrameP2P();
    };
}
